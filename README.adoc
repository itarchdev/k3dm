= Библиотека K3DM
Tepex <tepex@mail.ru>
1.0, 15/VI-2025
:source-highliter: rouge
:toc:
:toc-title: Содержание

K3DM (Kotlin DDD Model) — библиотека базовых типов, предназначенная для построения <<domain-model,моделей предметных областей>> на языке Котлин согласно с тактическими _DDD_-патернами — _Entity_ и _Value Object_. Состоит из конечной (закрытой) <<fst,*ФСТ*>>, аннотаций // и регламента построения <<cdt,*CDT*>>.

== Функциональные требования

=== Конечность
Количество возможных вариантов типов ограничено.

=== Валидируемость
Наличие механизма валидации при создании объекта заданного типа. Проверка входных параметров, из которых конструируется объект, на предмет допустимых значений.

=== Value Object
Предполагает свою иммутабельность. Однако, для операций над типами необходим механизм изменения свойств типа. _Entity_ пре




== Мотивация
[quote,Закон Е. А. Седова]
В сложной иерархически организованной системе рост разнообразия на верхнем уровне обеспечивается ограничением разнообразия на предыдущих уровнях, и наоборот, рост разнообразия на нижнем уровне разрушает верхний уровень организации (то есть, система как таковая гибнет).

Котлин является языком программирования общего назначения, предоставляющий очень широкие возможности для разработчика. В частности, — для проектирования собственных структур данных (типов). К сожалению, такая широта зачастую оборачивается появлением порочных практик, таких как мутабельность публичных свойств, одержимость примитивами (_primitive obsession_), нарушениями принципов _SOLID_ и пр.

При проектировании <<domain-model,*МПО*>> необходимо создать собственную <<fst,*ФСТ*>> с  обусловленными бизнес-требованиями правилами и ограничениями, возможностью валидации объектов при их создании, покрытию юнит-тестами логики <<domain-model,*МПО*>>. В свою очередь такая <<fst,*ФСТ*>> должна создаваться в рамках аксиоматики базовой <<fst,*ФСТ*>> высшего уровня, как основы, и которая бы воплощала концепцию тактических _DDD_-патернов — _Entity_ и _Value Object_.

Ограничения должны применяться на самых ранних этапах. Отчасти это возможно решить на уровне компиляции путем создания контрактов (абстрактых методов) в базовых интерфейсах и проверкой их логики юнит-тестами. Отчасти — наличием регламента, задающим эти ограничения. Проверка соблюдения регламента может осуществляться за счет дополнительных инструментов автоматизации: валидаторы кода, линтеры, кодогенераторы.

== Цель
- Создание закрытой базовой <<fst,*ФСТ*>>, воплощающую концепцию тактических _DDD_-патернов.
- Обеспечение механизма валидации <<cdt,*CDT*>> при создании объектов.
- Создание регламента проектирования <<cdt,*CDT*>>.

[#types]
== Базовая *ФСТ*
Интерфейсы <<kddd,*Fts*>> наследуются от корневого sealed-интерфейса `Fts` который имеет метод `validate()` предназначенный для валидации объектов при их создании. В переопределенных методах `validate()` должна реализовываться логика валидации объекта и выкидываться исключение `IllegalStateException` в рамках этой логики.

=== `IEntity : Fts`
Определяет тактический _DDD_-патерн _Entity_. Содержит поля:

- `id` — идентичность сущности.
- `content` — _Value Object_ содержимого сущности.

<<regulation,*Регламент*>> требует, что реализация этого интерфейса должна переопределять контракт `hashCode()/equals()`, завязав их на поле `id`. Отдельная группировка свойств сущности в свойство `content` обусловлена подходом, обоснованным у https://enterprisecraftsmanship.com/posts/nesting-value-object-inside-entity/[Вдадимира Хорикова].

=== `ValueObject : Fts`
Определяет тактический _DDD_-патерн _Value Object_. Sealed-интерфейс со следующими наследниками:

==== `ValueObject.Data`
Предназначен для проектирования <<cdt,*CDT*>> с несколькими свойствами и последующей имплементации <<cdt,*CDT*>> в виде `data class`. Декларирует метод `<T: Fts, A: Fts> fork(vararg args: A): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

==== `ValueObject.Value<BOXED: Any>`
Предназначен для проектирования *CDT* с одним свойством и последующей имплементации <<cdt,*CDT*>> в виде `value class`. Тип свойства определяется параметризованным типом `BOXED` и может быть либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>. Обусловлено борьбой с _одержимостью примитивами_. Декларирует метод `<T : Value<BOXED>> fork(boxed: BOXED): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

Метод `fork()` в контрактах интерфейсов `ValueObject` призван обеспечить возможность создания функционала/операций над этими типами на этапе декларации интерфейсов и, соответственно, компиляции, что обеспечивает возможность сразу создавать и запускать юнит-тесты с соответств прежде, чем будут .

[#annotations]
== Аннотации
- `KDGeneratable`
- `KDParsable`
- `KDIgnore`

[glossary]
[#domain-model]
== Термины и определения
МПО:: Модель Предметной Области (Domain Model) — совокупность типов данных и их функционала. https://martinfowler.com/eaaCatalog/domainModel.html[Определение по М. Фаулеру].
[#user]
Пользователь:: Разработчик (бизнес-аналитик, архитектор), использующий данную библиотеку для проектирования собственных типов (*CDT*) для некоторого своего домена.
[#fst]
ФСТ:: Формальная система типов, построенная на заданной аксиоматике — постулатах, определяющих допустимые границы значений и операции над типами.
[#pt]
ПТ:: Примитивный тип Котлин: `String`, `Int`, `Boolean`, и т.д.
[#ct]
ТОН:: Тип общего назначения из стандартных пакетов Java и Котлин, не требующих подключения специальных зависимостей: `File`, `UUID`, `URI`, и т.д.
[#kddd]
Fts:: Корневой тип библиотеки `k3dm`.
[#cdt]
CDT:: Customer Domain Type — проектируемый *Пользователем* собственный тип структуры данных.
